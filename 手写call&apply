
手写call和apply
1. 先要了解call方法是谁的？作用是什么
用call的操作
function f1(x，y){
  console.log(x+y)
  console.log('f1函数’，this)
}
var obj = { name: '小明'}
// f1时函数对象，引用变量，f1 时Function的实例对象
// f1对象中是没有call方法的，通过隐式原型链找到Function的prototype原型对象，该原型对象中有call方法
console.dir(Function)
f1.call(obj,10,20)

手写实现call
// 自己封装的一个函数 ------- 第一个思路
functin call(obj,...args){
  if( obj === null || obj === undefined ){
     obj = obj || window  
  }
  // fn中存储的是外部传入进来的f1函数对象
  obj.tempFn = fn
  // obj.tempFn(...args)相当于f1（10，20）的返回值 给了result
  const result = obj.tempFn(...args)
  // 把上面使用完毕的函数删除了（清理使用后的缓存数据）
  delete obj.tempFn
  //把f1函数调用后的结果返回
  return result
}
call(f1,obj,10,20)

// 如果希望自己封装的call方法针对任意的一个函数对象都可以使用，那么应该把call方法封装到Functino的prototype中；
干掉了Function的prototype原型对象中原有的call方法
// 自己封装的一个方法 -------- 第二个思路
Function.prototype.call1 = function(obj,...args){
  // 判断是否传了obj对象
  if( obj === null || obj === undefined ){
      obj = obj || window
  }
  // 此时代码能执行到这里，说明是一个对象调用了这个call方法，所以，this就是当前对象，又由于该对象一定是一个函数对象，所以，this是一个函数对象
  // 把当前的this存储起来（把这个函数存储起来）
  obj.tempFn = this
  // 调用这个函数
  obj.tempFn(...args)
}
f1.call1(obj,10,20)
  

// apply
f1.apply(obj,[10,20])  // apply的使用
// 手写实现apply
function apply(fn, obj, args){
  if(obj === null || obj === undefined ){
     obj = obj || window
  }
  obj.tempFn = fn
  const result = obj.tempFn(...args)
  delete obj.tempFn
  return result
}  
var result2 = apply(f1,obj,[10,20])
console.log（result2）


//手写一个数组的forEach的方法
Array.prototype.forEach = function(cb){
  // 此时的this就是数组的实例对象
  for( var i=0; i<this.length; i++ ){
      cb(this[i],i) 
  }
}

// 所有的数组实际上都是对象，都是Array的实例对象
var arr= [10,20,30]
arr.forEach((item,index)=>{      
  console.log(item,index)
})


  
 // 手写 bind功能
 /* 自定义函数对象的bind方法 
    重要技术： 高阶函数； 闭包； call（）；三点运算符
 */
 function bind(fn,obj,...args){
    if( obj === null || obj === undefined ){
      obj = obj || window
    }
    return function(...args2){
      return call(fn,obj,...args,...args2)
    }
 }
  


函数的节流和防抖
/*
    事件频繁触发可能造成的问题？
      1. 一些浏览器时间：window.onresize, window.mousemove等，触发的频率很高，会造成浏览器性能问题
      2. 如果向后台发送请求，对服务器造成不必要的压力
*/

节流： 窗口调整；页面滚动；拖拽功能；抢购疯狂点击
function throttle(callback,delay){
  let start = 0;
  return function(event){
    console.log('throttle节流事件')
    // 当前时间
    const current = Date.now()
    if( current - start > delay ){
        callback.call(this,event)
        // 重置开始时间
        start = current
    }
  }
}


防抖：在规定时间内，只让最后一次生效，前面的不生效。适合多次时间一次响应的情况。
使用场景：输入框实时搜索联想
function debounce(callback, delay){
  return function (event){
    console.log('debounce防抖事件')
    if( callback.timeId){
       clearTimeout(callback.timeId)
    }
    // 每隔delay的时间，启动一个心的延迟定时器
    callback.timeId = setTimeout(()=>{
      callback.call(this,event)
      // 如果定时器回调执行了，删除标记
      delete callback.timeId
    }, delay)
  }
}



















