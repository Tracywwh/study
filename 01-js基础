谈谈你对js的理解？
a.b的理解。   对象.属性  ==》预解析，作用域，执行上下文环境，闭包，原型


什么是变量？
var num = 10  // num是个地址，num中存的是可修改的值 ———— 变量
num = 20. // 10所在的空间被20覆盖了。但10这个值是没有变化的
理解：变量是个容器，容器里的数据是可以改变的


什么是常量？
const obj = {}  //对象/数组是可以改变的，但如果是数字就不能被改变了。

ECMASpcript标准定义了8种数据类型
1. 7种原始数据类型：String，Number，Boolean，Null，Undefined，Symbol，BigInt
2. Object


引用数据类型：Object，Function， Array，Date，RegExp

typeof运算符 —— 获得当前变量中存储的数据的类型
返回值：String，Number，Boolean，Undefined，Object，Function

instanceOf运算符： 对象 instanceOf 类型

内存： 用于暂时存放CPU中的运算数据以及与硬盘等外部存储器交换的数据





谈谈你对面向对象的理解？
涉及的内容有： 面向过程；面向对象；对象；原型；引用变量；闭包；作用域；预解析；执行上下文环境
面向过程还是面向对象都是编程思想；     （简单解释就是： 我饿了，我可以自己洗米做饭切菜下厨；也可以请厨师做饭，我直接吃现成的）
面向过程：凡事都是亲力亲为，注重的是过程；  
面向对象：提出需求，抽取出对象，调用对象相关的属性或者方法，获取结果
面向对象的特性：封装，继承，多态（抽象性）
对象：具有特征（属性）或者行为（方法）的特指的某个事物。 （看得见，摸得着，具体特质的某个东西。（比如：我面前的电脑显示屏就是对象，但显示屏不是对象，他是大范围。））
面向对象，需求： 通过手机打电话，分析，分析出里面的对象，具有什么样的特征和一些行为，对象是什么类型的，此时这些都属于分析的（过程）结果，----抽取出对象及特征和行为。
通过代码实现对象调用对应的属性和方法
特性 -----》属性；行为 -----〉方法；对象的类型 -----》类（类别）
构造函数拿上述举例来实现
eg： function Phone(color,weight){
  // 手机的对象的特征——》属性
  this.color = color
  this.weight = weight
  // 手机的对象的行为---》方法
  this.call = function(){
    console.log("nihao ")
  }
}
// 通过构造函数创建对应的一个具体的对象（实例化对象）
// 实例化对象的同时进行属性的初始化
var phone = new Phone('黑色','2kg‘)  // 相当于phone继承了Phone函数属性和方法
phone.call()


1. 字面量的方式创建对象： var obj = {}

2. 工厂模式创建对象: 
function createObject(name,age){
  var obj = new Object()
  obj.name=name
  obj.age=age
  return obj
}
var obj1 = createObject('小明', 10)
var obj2 = createObject('小红'，20)

3. 构造函数的方式创建对象
function Person(name,gender){
  this.name = name
  this.gender = gender
  this.sayHi=function(){
    console.log('hello')
  }
}
var teacher = new Person('Tracy','女')

4. 通过实例化class创建对象
 类的方式创建对象
class Student{
  // 构造器,构造器中的属性都在实例对象上的
  constructor(name,age,gender){
    this.name = name
    this.age = age
    this.gender = gender
  }
  // 在原型上
  sayHi(){
    console.log(`你好，我是${this.name},今年${this.age}岁了。`)
  }
  // class中书写方法的时候，如果方法使用的是赋值（=）符号的方式来定义，那么方法在实例上。
  // 在实例上
  eat = () =>{
    console.log('吃东西啊')
  }
  // 在实例上
  play = function(){
    console.log('在玩啊')
  }
}
var stu = new Student('小白',20,'男')
stu.sayHi()
stu.eat()
console.log(stu)

那么为什么有的赋值在原型上，有的写在实例上。
例如构造化函数
function Person(name){
  this.name=name
  this.sayHi=function(){ //在实例上
    console.log('你好')
  }
}
Person.prototype.eat=function(){ console.log('你好') }.  // 这个是在原型上
var person1 = new Person('小明')
var person2 = new Person('小明')
person1.sayHi === person2.sayHi ? ===>false
两个对象都有自己的sayHi方法，如果有多个对象，那么就会出现多个对象占用多块空间来存储自己的方法，浪费内存，既然方法中的内容都是一样的，
那么方法就应该放在原型上，占用一块空间，节省内存！



单例模式：不管该对象创建多少次，实际上，最终对象只有一个
简单的单里模式创建对象
function createObj(){
  var instance = null
  return function(name){
    if(!instance){
      // 创建对象
      instance = new Object()
      // 创建对象的属性值
      instance.name = name
    }
  // instance对象 已经创建完毕了，此时是存在的
  return instance
  }
}
var getObj = createObj()
var obj3 = getObj('小明')
var obj4 = getObj('小红')
console.log(obj3 === obj4) ==> true 因为执行小红的时候，instance已经存在，所以直接返回已经存在的instance，即小明，所以执行了2次，但只有一个对象小明
// 一个页面中有多个轮播图的效果，如果说此时为了实现轮播图的效果，那么就会创建对应的多个swiper的对象。此时可以使用单里模式的创建只创建一个对象，节省空间。
better-scroll 就是单例模式



原型
原型的理解：原型什么时候产生，原型有哪些，原型的作用，继承的实现，面向的编程思想
原型的应用------>vue中的事件总线---》vue中组件的通信的各种方式
vue.prototype.$bus = new Vue()
Vue.prototype.$API=API  ------>任意的组件中都可以直接调用api方法，调用接口，发送请求

执行函数定义和执行函数的区别？
// 函数定义（函数声明和函数表达式）
// 执行函数定义
function f1(){    //f1是函数，函数名，引用变量
  console.log('f1是函数')
}
//执行函数
f1() // 函数的调用————执行函数

原型是什么： 原型就是对象，js中原型一共有2个，prototype(显示)和_proto_（隐式）属性（实例对象有隐式原型）
原型什么时候产生的？
执行函数定义的时候，prototype显示原型就创建出来了，由于函数本身也是对象（实例对象），里面的隐式原型_proto_也产生了。
原型的理解：实例的_proto_与对应函数的prototype都指向原型对象，1. 函数里存在显示原型，实例对象里存在隐式原型
原型的作用：1. 共享数据，节省空间. 2. 实现继承
function Person(name){
  this.name=name
  this.eat=function(){ console.log('我喜欢吃') } // 这赋值方式是挂在实例上的。浪费内存空间
} 
var P1= new Person('小明')
var P2= new Person('小红')
小明和小红都会有一个各自的eat方法。重复，浪费内存
应该把eat挂在原型上。 Person.prototype.eat =function(){ ... } // 节省内存空间


通过改变原型执行实现继承
function Person(name){
  this.name = name
}
Person.prototype.sayHi=function(){
  console.log('hello')
}
function Student(name,age){
  // 二选一： 这是方法的继承
  this.name = name
  //二选一： 这是属性的继承
  Person.call(this,name)
  this.age=age
}
// 改变原型实现继承，可以使用父级类别中的方法（方法的继承）
Student.prototype = new Person() 
var stu = new Student(‘小明’，20)
stu.sayHi();
// 通过改变原型指向实现的是方法的继承，通过借用构造函数的方式实现的是属性的继承，二者结合在一起称为：组合继承 ---常用的继承方式



对象调用属性
var obj = {
  name: 'xiaoming'，  //值是字符串类型
  age: 12, // 值是数字类型
  sayHi: function(){  //值是函数类型
  }
}
调用对象的属性
obj.name; 
obj['name'];
var key = 'name'
obj[key];   ==》undefined  
obj.key 可以这么书写，不会报错，但意义不大，此时的key是当成属性来使用，结果是undefined，应用：Vue中可使用v-if好于v-show，因为.key可能会报错。


js是弱类型语言，申明变量都用var
js是脚本语言，直接执行
js是解释性语言，直接解释
js是动态类型语言，变量在执行的时候才知道具体的类型，对象没有这个属性，点了，就有了
js是单线程语言，执行的时候按照一定的顺序，之前的代码执行完毕后，后面才执行
js是基于对象的语言，最终所有的对象都指向了object



函数自调用
// js代码中是有可能会调用别人的js文件的，该文件中有可能有这种自动用的函数（）（）
;(function(){
})();


对象中有_proto_,函数中有prototype，实例对象中_proto_指向的是当前实例对象对应的构造函数中的prototype。
而每个prototype都是一个对象，所以，内部必然有——proto——，普通函数中的prototype的——proto——指向的都是Object的prototype
function Fn(){ }
var obj = {}
obj._proto_ === Object.prototype      ===> true 
Fn.prototype._proto_  === Object.protype      ===> true



原型链：隐式原型和显示原型之间的关系
var a = 10  // a是变量，值是数字类型，只有引用类型的对象可以点属性或者方法，去使用
// a是数字类型，但是由于a.b了，a就变成了基本包装类型（引用类型），
// a是一个对象了，b就是一个属性，但属性没有赋值
console.log(a.b)    ===> undefined 
a.b这个表达式中，总结知识点： 数据类型（null/undefined,string/number/boolean）作用域链（局部作用域/全局作用域），预解析
，执行上下文环境，原型/原型链 ---》及原型相关应用（事件总线）----〉vue技术点


function Foo（）{}. // 构造函数
const f1 = new Foo()
const f2 = new Foo()
const o1 = new Object()
const o2 = {}
Foo instanceof Object    ==> true
Foo instanceof Function  ==> true
Object instanceof Object ==> true
Function instanceof Function ==> true
Function instanceof Object ==> true
Object instanceof Foo  ===> false
f1 instanceof Function ===> false
f1 instanceof Object   ===> true

所有函数都是Funtion的实例对象

继承：改变原型指向/借用构造函数/组合/拷贝
改变原型指向:
function Fun(){}   
Fun.prototype.eat = function(){ ... }
借用构造函数:
function Foo(name,age){
  this.name=name
  this.age= age
}
Class类：
class Person{
  // 构造器，为了初始化对象中的属性
  constructor(name,age){
    this.name = name
    this.age = age 
  }
  eat = function(){ ... }
  sayHi(){ console.log('你好') }
}
class 与extends：
class Student extends Person{
  constructor(name,age,gender){
    // super 相当于.call结构构造函数实现属性的继承
    super(name,age)
    this.gender = gender
  }
  sayHi(){ console.log('我很好') }
}



js中的预解析，变量的声明提升了，函数的声明也提升了。函数表达式赋值的形式是不能提升。
eg：
console.log(num). // undefined,变量提升
var num = 10 

f1()
function f1(){
  console.log('哈哈哈，我是函数，函数声明能提升，我被执行了“)
}

f2（）
var f2 = function(){
  console.log('这是函数表达式，不能提升，报错了')
}

js的预解析：全局的预解析，局部的预解析
function f3(){
  console.log(number). // 这就是局部预解析
  var number = 100
}
f3()

预解析就是变量/函数的提升？
a()
var a = 10
function a (){ 
  console.log('函数') 
 }
console.log(a)

==> a变量和函数a都提升了。 执行得到 ： 函数， 10


f2（）
var f2 = function(){}
执行后会报错，相当于如下操作执行
var f2 // 函数变量提升。undefined
f2()   // undefined去执行，会报错
f2 = function(){}

预解析的理解：
js中预解析是存在的，预解析分为全局预解析和局部预解析。预解析做了什么呢，变量的提升，函数的提升。但值没有提升。
函数的表达式也不会被提升。代码在执行之前先出现预解析，把变量和函数声明提升，这时候执行上下文也出现了。


执行上下文： 一个代码的执行环境（全局执行上下文和函数执行上下文，eval函数执行上下文）
作用域是静态的，执行上下文环境是动态的。
scope 范围，作用域
流程： 
- js引擎在js代码正式执行前会先创建一个执行环境
- 进入到环境以后会先创建一个变量对象，该对象用于手机：变量，函数，函数的参数，this找关键字var，function
- js引擎在js代码正式执行前会先创建一个执行环境进入到环境以后会先创建一个变量对象，该对象用于手机：变量，函数，函数的参数，this
- 找关键字var，function
- 确认this
- 创建作用域链
先出现全局的执行上下文环境，压入栈中，在出现的局部执行上下文环境，在栈中的上面，局部的执行上下文结束后，先出栈。
（先进后出）

总结：当代码要执行，但是没有执行或将要执行，在预解析之后，此时出现了全局上下文环境，穿件了一个变量对象，用来收集var,function,函数参数，确定this的指向，默认全局执行上下文是确定了
this是window，这个变量对象会被压入到栈中，如果出现了函数调用，此时出现了局部执行上下文环境，再次穿件一个变量对象，用来收集函数参数，var,function,改变this的指向，这个变量对象会
被再次压入栈中，在全局执行上下文的变量对象的上面，如果当前函数调用完毕，此时出栈，依次弹出变量对象，就结束了。


作用域，预解析，执行上下文环境，原型，闭包（是个对象）都有相关联的

作用域： 
变量的使用范围，静态的，因为变量分为全局变量和局部变量，所以作用域分为全局作用域和局部作用域
function f1(){
  var num = 10
  return num //局部变量就可以在外部使用了。
}
希望能够缓存局部变量的数据，此时就可使用闭包


全局作用域： 函数外部变量的使用范围
局部作用域： 函数内变量的使用范围（一个函数就是一个作用域）
块级作用域（es6新增）：const/let
作用：隔离变量，不同的作用域下同名的变量不会冲突
变量分为：全局变量（非函数内部定义的变量）和局部变量（函数内部定义的变量）
多个嵌套的作用域形成的由内向外的结构，用于查找变量
eg:
let a = 0
function fn1(){
  let a1 = 100
  function fn2(){
    let a2 = 200
    function fn3(){
      let a3 = 300
      return a+a1+a2+a3
    }
    fn3()
  }
  fn2()
}
fn1()  ==> undefined

作用域与执行上下文
1. 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数确定时就已经确定了，而不是函数调用时。
2. 全局执行上下文环境在全局作用域确定之后，js代码马上执行之前创建
3. 函数执行上下文环境实在调用函数时，函数体代码执行之前创建
（先有作用域，再有预解析，才有执行上下文环境）
4. 作用域是静态的，只要函数定义好了就一直存在，且不会再变
5. 执行上下文是动态的，调用函数时创建，函数调用结束时上下文环境就会释放
6. 上下文环境（对象）是从属于所在的作用域
7. 全局上下文环境 ---》 全局作用域
8. 作用域链
  1. 用来决定代码执行的范围，变量的作用范围
  2. 作用域是代码定义的时候决定的
  3. 作用域链是如何生产的
  —— 函数在定义的时候自动添加一个属性[[scopes]]该属性保存的是其上级作用域链
  —— 当函数执行的时候，进入执行上下文环境，将创建的变量对象添加到[[scopes]]数组的第一个位置，
  形成心的书序
  4. 查找变量的规则
  —— 先在当前作用域的变量对象中查找，找到则使用
  —— 如果没有则沿着作用域链的数组去上级作用域中的变量对象中查找
  —— 找到就返回对应的值，如果没有继续向上查找，直到找到最后一个变量对象（全局的变量对象），如果没有则报错
 代码编写的时候确定了当前全局作用域及局部作用域
 在代码马上执行，还没执行，执行上下文环境就出现了，函数调用完毕后，局部执行上下文没了，整个代码结束，全局的执行上下文环境也没了
 全局作用域 --> 预解析 --> 全局执行上下文环境 --> 全局的变量对象（var,function,函数参数，this的指向）
 ---> 函数定义 --> 局部作用域 --> 出现了函数调用 --> 局部预解析 --> 局部的指向上下文环境 --> 局部的变量对象（var,function,函数参数，this的指向）
 
// 当代码书写完毕后，全局作用域就已经确定好了，然后代码执行之前，预解析出现了，然后全局的执行上下文就出现了，
调用函数之前，局部作用域就出现了，


闭包
闭包的理解？闭包什么时候产生的；闭包是啥；为什么有闭包；闭包的优缺点；闭包的应用
函数之间有嵌套关系，内部函数调用到了外部函数的变量，内部函数在执行该函数定义的时候，此时形成了闭包。

























