基础知识 + 【高级特性+原理】 + 【设计+经验】

工具： webpack配置 ； 性能优化； babel 。
项目设计： 状态设计 ； 组件设计 ； 组件通讯 。


vue使用
*基本使用，组件使用
*高级特性 —————— 不常用，但体现深度
*vuex和vue-router使用

/* 文档是备忘录，给会用的人查阅，并不是入门教程 */
用vue-cli创建项目

指令；插值
插值、表达式
指令、动态属性
v-html：会有xss风险，会覆盖子组件
computed有缓存，data不变则不会重新计算
watch如何深度监听？
watch监听引用类型，拿不到oldVal


v-model 自定义的v-model把data做数据双向绑定

v-if + v-else-if +v-else ： 不渲染的，性能好，会重新渲染
v-show 渲染频繁的，用这个方式，不符合要求的display：none隐藏


父子组件： props ； $emit
组件间通讯-自定义事件
组件生命周期： 挂载 ==》 更新 ==〉 卸载
vue高级特性：v-model; $nextTick；slot插槽；动态、异步组件；keep-alive缓存提高性能；mixin;
 
vue组件如何通讯
 1. 属性和触发事件的形式
 2. 自定义事件
 3. vuex的通讯
 
 
vue和react都是异步渲染的框架
data改变之后，DOM不会立即渲染
$nextTick会在DOM渲染之后被触发，以获取最新DOM节点

// 异步渲染，$nectTick待DOM渲染完再回调
// 页面渲染时会将data的修改做 整合，多次data修改只会渲染一次
this.$nextTick(()=>{
   const ulElem = this.$refs.ul1  （对应的是<ul ref="ul1">...</ul>）
   console.log(elElem.childNodes.length)   (能立即获得当前点击后的数据)
})

slot插槽：
基本使用； 作用域插槽； 具名插槽
应用：就是父组件中没有内容的时候，子组件中可以用替换值展示。如果父组件中有内容，则子组件中的不展示。
父组件：<SlotDemo :url="xxx" >{{ textName = 这里为空的时候，子组件的slot内的内容会展示。 }}</SlotDemo>
子组件SlotDemo中： 
<a :href="url" > 
   <slot> 默认内容，即父组件没设置内容时，这里显示,可以是组件 </slot>
</a>


slot-具名插槽
<!--NameSlot 组件---->
<div class="container">
  <header><slot name="footer"></slot></header>
  <main><slot></slot></main>
  <footer><slot name="footer"></slot></footer>
</div>

<NameSlot>
   // <template #header> 也可以这么写
   <template v-slot:header><h1>将插入到header slot中</h1></template>
   <p>将插入到main slot中，即未命名的slot</p>
   <template v-slot:footer><p>将插入到footer slot中</p></template>
</NameSlot>


动态组件：
:is = "component-name" 用法
需要根据数据，动态渲染的场景。即组件类型不确定

动态添加路由： addRoutes
router.addRoutes(routes)
应有场景： 权限
在异步确定用户的权限路由后，需要动态添加到路由器  

prefetch
<link href="xxx" rel="prefetch" >  prefetch 预加载
<link href="xxx" rel="preload" as="style" > preload 预加载


异步加载组件：用的时候加载，不用不加载，提升性能
1. import（）函数；
2. 按需加载，异步加载大组件； 
按需加载的举例：
<FormDemo v-if="showFormDemo" />.  // 控制showFormDemo，false的时候不加载，true了加载
import FormDemo from './FormDemo'   // 这是直接引用组件，直接一起打包的
export default{
   compomemts:{
      FormDemo: () => import('./FormDemo').  //这里就是按需加载组件
  }
}


keep-alive 缓存组件，vue常见性能优化
缓存组件； 
频繁切换，不需要重复渲染
<keep-alive>
   // 下面3个组件，当state满足条件后会重新渲染下面的组件，但反复点击反复显示满足条件的组件，会浪费内存，消耗。但组件外加了<keep-alive>就能缓存组件了。keep-alive是vue层级来控制复杂的tab操作的，v-show是样式控制的控制简单的
   <KeepAliveStageA v-if="state === 'A' " />
   <KeepAliveStageB v-if="state === 'B' " />
   <KeepAliveStageC v-if="state === 'C' " /> 
</keep-alive>


mixin
多个组件有相同的逻辑，抽离出来
mixin并不是完美的解决方案，会有一些问题
Vue3提出的compositionAPI能解决这些问题
import myMixin from './mixin'  
export default{
   mixins: [myMixin],  //可以添加多个，会自动合并起来（写一遍，多处引用去使用；如果有多个/他人写的，那么维护会比较困难；可能造成命名冲突；）
   data(){}
}


vue-router
声明式路由： <router-link to="/xxx" replace>xxx</router-link> （标签）
编程式路由： this.$router.push(location) 或者replace的方式 （js）
传参方式：
params 参数： 占位方式 /xxx/:name/:age
query 参数： 可传可不传 /order/list?page=1
props： {a:1, b:2 }
meta：可以传递参数
遇到的困难： 编程式路由跳转，跳转到当前页面，一直有报错？
在3.10版本后要promise形式，就是在this.$router.push(location).then().catch(),但也不能每个都这么做，很繁琐，查文档后发现可以在路由器原型对象上重新定义push和replace方法


hash模式(默认)： http://abc.com/#user/10     用这种的话是不会进入404页面的，都是先进入index.html的。前端要自行配置跳转404页面
h5 history模式： http://abc.com/user/20。
后者需要server端支持，因此无特殊需求可选择前者  
怎么解决history容易跳入404页面？
解决方式： 开发环境：webpack中的devServer代理： { historyApiFallback: true }
生产环境打包： 配置nginx ==》 location / { try $uri // index.html; }  // 所有404的请求都返回到index页面

hash和history内部的原理？
hash：内部利用的是location对象的hash语法。
history：内部利用的是history对象的pushState（）和replaceState（） （h5新语法 ）

const User = {...}
const router = new VueRouter({
    routes: [{
       path: '/user/:id', component: User. // :id就是动态路径参数，就是动态路由 
    },{
       path: '/feedback',
       component:()=> import(' ./../component/FeedBack')    //懒加载，跟组件的异步加载一样的。到这个页面后加载这个组件
    }]
})



vuex 
action中放异步；mutation中放同步；
vuex中的mutation可以执行异步操作吗？ 
1. 可以 ==》 异步更新数据后界面确实会自动更新
2. 问题 ==〉 vuex的调用工具监视不到mutation中的异步更新，工具记录还是更新前的数据（不对）
3. 扩展：工具如何积累数据变化？ ==》 每次mutation函数执行完后，立即记录当前的数据 ==〉 在mutation中同时更新state，才能被记录到

vuex中的状态数据的响应的原理？
1. 创建了一个vm对象
2. state中的数据都是wm的data数据（是响应式的）
3. 组件中读取的state数据本质读取的就是data中的数据
4. 一旦更新了state中的数据，所有用到这个数据的组件就会自动更新

vuex数据刷新丢失的问题？
1. 绑定事件监听：在卸载前保存当前数据
2. 在初始时读取保存数据作为状态的初始值


















